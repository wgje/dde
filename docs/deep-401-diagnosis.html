<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>401 æ·±åº¦è¯Šæ–­å·¥å…·</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px; 
      margin: 0 auto; 
      padding: 20px;
      background: #0d1117;
      color: #c9d1d9;
    }
    h1, h2, h3 { color: #58a6ff; }
    .card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
    }
    .success { border-left: 4px solid #3fb950; }
    .error { border-left: 4px solid #f85149; }
    .warning { border-left: 4px solid #d29922; }
    .info { border-left: 4px solid #58a6ff; }
    button {
      background: #238636;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px;
    }
    button:hover { background: #2ea043; }
    button:disabled { background: #484f58; cursor: not-allowed; }
    button.danger { background: #da3633; }
    button.danger:hover { background: #f85149; }
    pre {
      background: #0d1117;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 12px;
      border: 1px solid #30363d;
    }
    input {
      background: #0d1117;
      border: 1px solid #30363d;
      color: #c9d1d9;
      padding: 8px 12px;
      border-radius: 6px;
      width: 100%;
      margin: 5px 0;
    }
    .step { 
      counter-increment: step;
      position: relative;
    }
    .step::before {
      content: "Step " counter(step);
      background: #238636;
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      margin-right: 8px;
    }
    #results { counter-reset: step; }
    .test-item {
      display: flex;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #30363d;
    }
    .test-item:last-child { border-bottom: none; }
    .status-icon { 
      width: 24px; 
      height: 24px; 
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 12px;
      font-size: 14px;
    }
    .status-pass { background: #238636; }
    .status-fail { background: #da3633; }
    .status-warn { background: #d29922; }
    .status-pending { background: #484f58; }
    .diagnosis-result {
      background: #1c2128;
      border-radius: 8px;
      padding: 16px;
      margin-top: 20px;
    }
    .fix-step {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 12px;
      margin: 8px 0;
    }
    .fix-step code {
      background: #161b22;
      padding: 2px 6px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>ğŸ” 401 Unauthorized æ·±åº¦è¯Šæ–­å·¥å…·</h1>
  
  <div class="card info">
    <p><strong>ä½¿ç”¨è¯´æ˜ï¼š</strong></p>
    <ol>
      <li>å¡«å†™ä½ çš„ Supabase é…ç½®ï¼ˆä» Supabase Dashboard è·å–ï¼‰</li>
      <li>ç‚¹å‡» "å¼€å§‹æ·±åº¦è¯Šæ–­" æŒ‰é’®</li>
      <li>æ ¹æ®è¯Šæ–­ç»“æœï¼Œç³»ç»Ÿä¼šç»™å‡ºå…·ä½“çš„ä¿®å¤å»ºè®®</li>
    </ol>
  </div>

  <div class="card">
    <h3>é…ç½®ä¿¡æ¯</h3>
    <label>Supabase URL:</label>
    <input type="text" id="supabaseUrl" value="https://fkhihclpghmmtbbywvoj.supabase.co" placeholder="https://xxx.supabase.co">
    
    <label>Supabase Anon Key:</label>
    <input type="text" id="supabaseAnonKey" value="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZraGloY2xwZ2htbXRiYnl3dm9qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgwNDIyMTgsImV4cCI6MjA4MzYxODIxOH0.4Z5eylbmBA-YFiDRvDtom4lTHavHP3JfVmrU0yH9oVo" placeholder="eyJhbG...">
    
    <label>é‚®ç®±ï¼ˆå¯é€‰ï¼Œç”¨äºè‡ªåŠ¨ç™»å½•æµ‹è¯•ï¼‰:</label>
    <input type="text" id="email" placeholder="your@email.com">
    
    <label>å¯†ç ï¼ˆå¯é€‰ï¼‰:</label>
    <input type="password" id="password" placeholder="your password">
  </div>

  <div class="card">
    <button id="startDiagnosis" onclick="runFullDiagnosis()">ğŸ” å¼€å§‹æ·±åº¦è¯Šæ–­</button>
    <button onclick="clearResults()">ğŸ—‘ï¸ æ¸…é™¤ç»“æœ</button>
  </div>

  <div id="results"></div>

  <script>
    let supabase = null;
    let diagnosisResults = {
      configValid: false,
      canConnect: false,
      hasSession: false,
      tokenValid: false,
      tokenNotExpired: false,
      edgeFunctionExists: false,
      edgeFunctionAcceptsRequest: false,
      jwtVerifyEnabled: null,
      authHeaderSent: false,
      specificError: null
    };

    function log(message, type = 'info') {
      const resultsDiv = document.getElementById('results');
      const card = document.createElement('div');
      card.className = `card ${type}`;
      card.innerHTML = message;
      resultsDiv.appendChild(card);
      console.log(message.replace(/<[^>]*>/g, ''));
    }

    function clearResults() {
      document.getElementById('results').innerHTML = '';
    }

    async function runFullDiagnosis() {
      clearResults();
      document.getElementById('startDiagnosis').disabled = true;
      
      log('<h2>ğŸ” å¼€å§‹æ·±åº¦è¯Šæ–­...</h2>', 'info');
      
      try {
        // Step 1: éªŒè¯é…ç½®
        await testConfig();
        
        // Step 2: æµ‹è¯•è¿æ¥
        await testConnection();
        
        // Step 3: æ£€æŸ¥ Session
        await testSession();
        
        // Step 4: éªŒè¯ Token
        await testToken();
        
        // Step 5: ç›´æ¥æµ‹è¯• Edge Functionï¼ˆç»•è¿‡ SDKï¼‰
        await testEdgeFunctionDirect();
        
        // Step 6: ä½¿ç”¨ SDK æµ‹è¯• Edge Function
        await testEdgeFunctionWithSDK();
        
        // Step 7: åˆ†æç»“æœå¹¶ç»™å‡ºå»ºè®®
        await analyzeAndRecommend();
        
      } catch (error) {
        log(`<strong>âŒ è¯Šæ–­è¿‡ç¨‹å‡ºé”™ï¼š</strong><pre>${error.message}\n${error.stack}</pre>`, 'error');
      }
      
      document.getElementById('startDiagnosis').disabled = false;
    }

    async function testConfig() {
      log('<div class="step"><strong>éªŒè¯é…ç½®ä¿¡æ¯</strong></div>', 'info');
      
      const url = document.getElementById('supabaseUrl').value.trim();
      const key = document.getElementById('supabaseAnonKey').value.trim();
      
      const issues = [];
      
      if (!url || !url.startsWith('https://')) {
        issues.push('Supabase URL æ ¼å¼æ— æ•ˆ');
      }
      
      if (!key || key.length < 100) {
        issues.push('Anon Key æ ¼å¼æ— æ•ˆ');
      }
      
      // è§£æ JWT æŸ¥çœ‹å†…å®¹
      try {
        const payload = JSON.parse(atob(key.split('.')[1]));
        log(`<pre>JWT Payload è§£æ:
- iss: ${payload.iss}
- ref: ${payload.ref}
- role: ${payload.role}
- iat: ${new Date(payload.iat * 1000).toLocaleString()}
- exp: ${new Date(payload.exp * 1000).toLocaleString()}</pre>`, 'info');
        
        if (payload.role !== 'anon') {
          issues.push(`âš ï¸ Key çš„ role æ˜¯ "${payload.role}"ï¼Œå‰ç«¯åº”è¯¥ä½¿ç”¨ "anon" key`);
        }
      } catch (e) {
        issues.push('æ— æ³•è§£æ JWT payload');
      }
      
      if (issues.length === 0) {
        diagnosisResults.configValid = true;
        log('âœ… é…ç½®æ ¼å¼æœ‰æ•ˆ', 'success');
        
        // åˆå§‹åŒ– Supabase
        supabase = window.supabase.createClient(url, key, {
          auth: {
            autoRefreshToken: true,
            persistSession: true
          }
        });
      } else {
        log(`âŒ é…ç½®é—®é¢˜ï¼š<ul>${issues.map(i => `<li>${i}</li>`).join('')}</ul>`, 'error');
      }
    }

    async function testConnection() {
      log('<div class="step"><strong>æµ‹è¯• Supabase è¿æ¥</strong></div>', 'info');
      
      if (!supabase) {
        log('â­ï¸ è·³è¿‡ï¼ˆé…ç½®æ— æ•ˆï¼‰', 'warning');
        return;
      }
      
      try {
        // å°è¯•è·å–ç”¨æˆ·ï¼ˆå³ä½¿æœªç™»å½•ä¹Ÿèƒ½æµ‹è¯•è¿æ¥ï¼‰
        const { error } = await supabase.auth.getSession();
        
        if (error && error.message.includes('fetch')) {
          log('âŒ æ— æ³•è¿æ¥åˆ° Supabaseï¼ˆç½‘ç»œé—®é¢˜ï¼‰', 'error');
        } else {
          diagnosisResults.canConnect = true;
          log('âœ… å¯ä»¥è¿æ¥åˆ° Supabase', 'success');
        }
      } catch (e) {
        log(`âŒ è¿æ¥æµ‹è¯•å¤±è´¥: ${e.message}`, 'error');
      }
    }

    async function testSession() {
      log('<div class="step"><strong>æ£€æŸ¥ç”¨æˆ· Session</strong></div>', 'info');
      
      if (!supabase) {
        log('â­ï¸ è·³è¿‡', 'warning');
        return;
      }
      
      try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
          log(`âŒ è·å– Session å¤±è´¥: ${error.message}`, 'error');
          return;
        }
        
        if (!session) {
          log('âš ï¸ å½“å‰æ²¡æœ‰ Sessionï¼ˆæœªç™»å½•ï¼‰', 'warning');
          
          // å°è¯•ç™»å½•
          const email = document.getElementById('email').value.trim();
          const password = document.getElementById('password').value;
          
          if (email && password) {
            log('ğŸ”„ å°è¯•ä½¿ç”¨æä¾›çš„å‡­æ®ç™»å½•...', 'info');
            const { data, error: loginError } = await supabase.auth.signInWithPassword({
              email,
              password
            });
            
            if (loginError) {
              log(`âŒ ç™»å½•å¤±è´¥: ${loginError.message}`, 'error');
            } else {
              diagnosisResults.hasSession = true;
              log(`âœ… ç™»å½•æˆåŠŸ: ${data.user.email}`, 'success');
            }
          } else {
            log('ğŸ’¡ æä¾›é‚®ç®±å’Œå¯†ç å¯ä»¥è¿›è¡Œå®Œæ•´æµ‹è¯•', 'info');
          }
        } else {
          diagnosisResults.hasSession = true;
          log(`âœ… Session å­˜åœ¨
<pre>ç”¨æˆ·: ${session.user.email}
ID: ${session.user.id}
Token å‰ 50 å­—ç¬¦: ${session.access_token.substring(0, 50)}...</pre>`, 'success');
        }
      } catch (e) {
        log(`âŒ Session æ£€æŸ¥å¤±è´¥: ${e.message}`, 'error');
      }
    }

    async function testToken() {
      log('<div class="step"><strong>éªŒè¯ Access Token</strong></div>', 'info');
      
      if (!supabase) {
        log('â­ï¸ è·³è¿‡', 'warning');
        return;
      }
      
      try {
        const { data: { session } } = await supabase.auth.getSession();
        
        if (!session) {
          log('â­ï¸ æ²¡æœ‰ Sessionï¼Œè·³è¿‡ Token éªŒè¯', 'warning');
          return;
        }
        
        const token = session.access_token;
        
        // è§£æ Token
        const parts = token.split('.');
        if (parts.length !== 3) {
          log('âŒ Token æ ¼å¼æ— æ•ˆï¼ˆä¸æ˜¯æœ‰æ•ˆçš„ JWTï¼‰', 'error');
          return;
        }
        
        const payload = JSON.parse(atob(parts[1]));
        const now = Math.floor(Date.now() / 1000);
        const expiresAt = payload.exp;
        const issuedAt = payload.iat;
        const timeLeft = expiresAt - now;
        
        log(`<pre>Access Token è§£æ:
- ç”¨æˆ· ID (sub): ${payload.sub}
- è§’è‰² (role): ${payload.role}
- ç­¾å‘æ—¶é—´: ${new Date(issuedAt * 1000).toLocaleString()}
- è¿‡æœŸæ—¶é—´: ${new Date(expiresAt * 1000).toLocaleString()}
- å‰©ä½™æœ‰æ•ˆæœŸ: ${Math.round(timeLeft / 60)} åˆ†é’Ÿ
- aud: ${payload.aud}
- iss: ${payload.iss}</pre>`, 'info');
        
        if (timeLeft < 0) {
          log(`âŒ Token å·²è¿‡æœŸ ${Math.abs(Math.round(timeLeft / 60))} åˆ†é’Ÿï¼`, 'error');
          diagnosisResults.specificError = 'TOKEN_EXPIRED';
          
          // å°è¯•åˆ·æ–°
          log('ğŸ”„ å°è¯•åˆ·æ–° Token...', 'info');
          const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession();
          
          if (refreshError) {
            log(`âŒ åˆ·æ–°å¤±è´¥: ${refreshError.message}`, 'error');
          } else if (refreshData.session) {
            log('âœ… Token åˆ·æ–°æˆåŠŸï¼', 'success');
            diagnosisResults.tokenValid = true;
            diagnosisResults.tokenNotExpired = true;
          }
        } else if (timeLeft < 300) {
          log(`âš ï¸ Token å³å°†è¿‡æœŸï¼ˆå‰©ä½™ ${Math.round(timeLeft / 60)} åˆ†é’Ÿï¼‰`, 'warning');
          diagnosisResults.tokenValid = true;
        } else {
          diagnosisResults.tokenValid = true;
          diagnosisResults.tokenNotExpired = true;
          log('âœ… Token æœ‰æ•ˆä¸”æœªè¿‡æœŸ', 'success');
        }
        
      } catch (e) {
        log(`âŒ Token éªŒè¯å¤±è´¥: ${e.message}`, 'error');
      }
    }

    async function testEdgeFunctionDirect() {
      log('<div class="step"><strong>ç›´æ¥æµ‹è¯• Edge Functionï¼ˆä¸ä½¿ç”¨ SDKï¼‰</strong></div>', 'info');
      
      const url = document.getElementById('supabaseUrl').value.trim();
      const anonKey = document.getElementById('supabaseAnonKey').value.trim();
      const functionUrl = `${url}/functions/v1/transcribe`;
      
      // æµ‹è¯• 1: å®Œå…¨æ²¡æœ‰è®¤è¯å¤´
      log('ğŸ“¡ æµ‹è¯• 1: ä¸å¸¦ä»»ä½•è®¤è¯å¤´...', 'info');
      try {
        const resp1 = await fetch(functionUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ test: true })
        });
        
        const text1 = await resp1.text();
        log(`<pre>çŠ¶æ€: ${resp1.status}
å“åº”: ${text1}</pre>`, resp1.status === 401 ? 'warning' : 'info');
        
        if (resp1.status === 401 && text1.includes('Invalid JWT')) {
          log('ğŸ” å‘ç°ï¼šSupabase åœ¨è¯·æ±‚åˆ°è¾¾ Edge Function ä»£ç ä¹‹å‰å°±æ‹’ç»äº†ï¼ˆJWT éªŒè¯å±‚ï¼‰', 'warning');
          diagnosisResults.jwtVerifyEnabled = true;
        } else if (resp1.status === 401 && text1.includes('AUTH_REQUIRED')) {
          log('ğŸ” å‘ç°ï¼šè¯·æ±‚åˆ°è¾¾äº† Edge Functionï¼Œæ˜¯ä»£ç å±‚æ‹’ç»çš„', 'info');
          diagnosisResults.jwtVerifyEnabled = false;
          diagnosisResults.edgeFunctionExists = true;
        }
      } catch (e) {
        log(`âŒ è¯·æ±‚å¤±è´¥: ${e.message}`, 'error');
      }
      
      // æµ‹è¯• 2: åªå¸¦ apikey å¤´
      log('ğŸ“¡ æµ‹è¯• 2: åªå¸¦ apikey å¤´ï¼ˆæ—  Authorizationï¼‰...', 'info');
      try {
        const resp2 = await fetch(functionUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'apikey': anonKey
          },
          body: JSON.stringify({ test: true })
        });
        
        const text2 = await resp2.text();
        log(`<pre>çŠ¶æ€: ${resp2.status}
å“åº”: ${text2}</pre>`, resp2.status === 401 ? 'warning' : 'info');
        
        if (resp2.status === 401 && text2.includes('Invalid JWT')) {
          log('ğŸ” å‘ç°ï¼šå³ä½¿æœ‰ apikeyï¼Œä»éœ€è¦ Authorization å¤´ï¼ˆJWT éªŒè¯å¯ç”¨ï¼‰', 'warning');
        }
      } catch (e) {
        log(`âŒ è¯·æ±‚å¤±è´¥: ${e.message}`, 'error');
      }
      
      // æµ‹è¯• 3: å¸¦ Authorization: Bearer anon_key
      log('ğŸ“¡ æµ‹è¯• 3: Authorization ä½¿ç”¨ anon key...', 'info');
      try {
        const resp3 = await fetch(functionUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'apikey': anonKey,
            'Authorization': `Bearer ${anonKey}`
          },
          body: JSON.stringify({ test: true })
        });
        
        const text3 = await resp3.text();
        log(`<pre>çŠ¶æ€: ${resp3.status}
å“åº”: ${text3}</pre>`, resp3.status < 300 ? 'success' : 'warning');
        
        if (resp3.status === 200 || resp3.status === 400) {
          // 400 å¯èƒ½æ˜¯å› ä¸ºæ²¡æœ‰å‘é€éŸ³é¢‘æ–‡ä»¶ï¼Œä½†è¯´æ˜è®¤è¯é€šè¿‡äº†
          log('âœ… ä½¿ç”¨ anon key ä½œä¸º Authorization å¯ä»¥é€šè¿‡ï¼', 'success');
          diagnosisResults.edgeFunctionAcceptsRequest = true;
          diagnosisResults.specificError = 'ANON_KEY_WORKS_BUT_USER_TOKEN_FAILS';
        } else if (resp3.status === 401 && text3.includes('AUTH_INVALID')) {
          log('ğŸ” å‘ç°ï¼šanon key ä¸è¢«æ¥å—ä¸ºç”¨æˆ· tokenï¼ˆè¿™æ˜¯æ­£å¸¸çš„ï¼‰', 'info');
        }
      } catch (e) {
        log(`âŒ è¯·æ±‚å¤±è´¥: ${e.message}`, 'error');
      }
      
      // æµ‹è¯• 4: å¸¦æœ‰æ•ˆç”¨æˆ· Token
      if (supabase) {
        const { data: { session } } = await supabase.auth.getSession();
        if (session) {
          log('ğŸ“¡ æµ‹è¯• 4: Authorization ä½¿ç”¨ç”¨æˆ· access_token...', 'info');
          try {
            const resp4 = await fetch(functionUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'apikey': anonKey,
                'Authorization': `Bearer ${session.access_token}`
              },
              body: JSON.stringify({ test: true })
            });
            
            const text4 = await resp4.text();
            log(`<pre>çŠ¶æ€: ${resp4.status}
å“åº”: ${text4}</pre>`, resp4.status < 300 ? 'success' : (resp4.status === 400 ? 'success' : 'error'));
            
            if (resp4.status === 200 || resp4.status === 400) {
              log('âœ… ç”¨æˆ· Token è®¤è¯æˆåŠŸï¼ï¼ˆ400 æ˜¯å› ä¸ºæ²¡å‘é€éŸ³é¢‘æ–‡ä»¶ï¼‰', 'success');
              diagnosisResults.authHeaderSent = true;
            } else if (resp4.status === 401) {
              log('âŒ ç”¨æˆ· Token è¢«æ‹’ç»ï¼', 'error');
              
              // è§£æå…·ä½“é”™è¯¯
              try {
                const errObj = JSON.parse(text4);
                if (errObj.code === 'AUTH_INVALID') {
                  diagnosisResults.specificError = 'USER_TOKEN_INVALID_AT_FUNCTION';
                  log('ğŸ” Edge Function å†…éƒ¨éªŒè¯å¤±è´¥ï¼ˆgetUser è¿”å›é”™è¯¯ï¼‰', 'error');
                } else if (errObj.message?.includes('Invalid JWT')) {
                  diagnosisResults.specificError = 'JWT_VERIFY_LAYER_REJECTION';
                  log('ğŸ” Supabase JWT éªŒè¯å±‚æ‹’ç»äº†è¯·æ±‚', 'error');
                }
              } catch (e) {}
            }
          } catch (e) {
            log(`âŒ è¯·æ±‚å¤±è´¥: ${e.message}`, 'error');
          }
        }
      }
    }

    async function testEdgeFunctionWithSDK() {
      log('<div class="step"><strong>ä½¿ç”¨ Supabase SDK æµ‹è¯• Edge Function</strong></div>', 'info');
      
      if (!supabase) {
        log('â­ï¸ è·³è¿‡ï¼ˆSupabase æœªåˆå§‹åŒ–ï¼‰', 'warning');
        return;
      }
      
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        log('â­ï¸ è·³è¿‡ï¼ˆæœªç™»å½•ï¼‰', 'warning');
        return;
      }
      
      log('ğŸ“¡ è°ƒç”¨ supabase.functions.invoke("transcribe")...', 'info');
      
      try {
        // åˆ›å»ºä¸€ä¸ªå°çš„æµ‹è¯•éŸ³é¢‘ blob
        const testBlob = new Blob(['test'], { type: 'audio/webm' });
        const formData = new FormData();
        formData.append('file', testBlob, 'test.webm');
        
        const { data, error } = await supabase.functions.invoke('transcribe', {
          body: formData
        });
        
        if (error) {
          log(`<pre>SDK è°ƒç”¨å¤±è´¥:
é”™è¯¯ç±»å‹: ${error.name}
æ¶ˆæ¯: ${error.message}
ä¸Šä¸‹æ–‡: ${JSON.stringify(error.context, null, 2)}</pre>`, 'error');
          
          if (error.message.includes('401') || error.message.includes('non-2xx')) {
            diagnosisResults.specificError = 'SDK_401_ERROR';
          }
        } else {
          log(`<pre>SDK è°ƒç”¨æˆåŠŸ:
${JSON.stringify(data, null, 2)}</pre>`, 'success');
        }
      } catch (e) {
        log(`âŒ SDK è°ƒç”¨å¼‚å¸¸: ${e.message}`, 'error');
      }
    }

    async function analyzeAndRecommend() {
      log('<h2>ğŸ“‹ è¯Šæ–­ç»“æœä¸ä¿®å¤å»ºè®®</h2>', 'info');
      
      const results = diagnosisResults;
      let diagnosis = '';
      let fixes = [];
      
      // åˆ†æé—®é¢˜æ ¹å› 
      if (results.jwtVerifyEnabled === true && !results.authHeaderSent) {
        diagnosis = `
          <h3>ğŸ¯ é—®é¢˜å®šä½ï¼šEdge Function å¯ç”¨äº† JWT éªŒè¯</h3>
          <p>Supabase Edge Function åœ¨é»˜è®¤éƒ¨ç½²æ—¶ä¼šå¯ç”¨ JWT éªŒè¯ã€‚
          è¿™æ„å‘³ç€æ¯ä¸ªè¯·æ±‚å¿…é¡»åœ¨ <code>Authorization</code> å¤´ä¸­æºå¸¦æœ‰æ•ˆçš„ç”¨æˆ· Access Tokenã€‚</p>
          <p><strong>é—®é¢˜ï¼š</strong> å‰ç«¯å‘é€çš„ Token æ— æ³•é€šè¿‡ Supabase çš„ JWT éªŒè¯å±‚ã€‚</p>
        `;
        
        fixes = [
          {
            title: 'æ–¹æ¡ˆ Aï¼šé‡æ–°éƒ¨ç½² Edge Functionï¼ˆç¦ç”¨ JWT éªŒè¯ï¼‰',
            steps: [
              'è¿™æ˜¯æœ€å¿«çš„è§£å†³æ–¹æ¡ˆï¼Œè®© Edge Function è‡ªå·±å¤„ç†è®¤è¯',
              '<code>supabase functions deploy transcribe --no-verify-jwt</code>',
              'âš ï¸ æ³¨æ„ï¼šå‡½æ•°å†…éƒ¨ä»£ç å·²ç»æœ‰è®¤è¯é€»è¾‘ï¼Œæ‰€ä»¥è¿™æ ·åšæ˜¯å®‰å…¨çš„'
            ]
          },
          {
            title: 'æ–¹æ¡ˆ Bï¼šæ£€æŸ¥ç”¨æˆ·ç™»å½•çŠ¶æ€',
            steps: [
              'ç¡®ä¿ç”¨æˆ·å·²ç™»å½•ä¸” Session æœ‰æ•ˆ',
              'åœ¨æµè§ˆå™¨æ§åˆ¶å°æ‰§è¡Œï¼š',
              '<code>const { data } = await supabase.auth.getSession(); console.log(data.session);</code>',
              'å¦‚æœ session ä¸º nullï¼Œéœ€è¦é‡æ–°ç™»å½•'
            ]
          },
          {
            title: 'æ–¹æ¡ˆ Cï¼šæ£€æŸ¥ Token åˆ·æ–°æœºåˆ¶',
            steps: [
              'ç¡®ä¿ Supabase Client é…ç½®äº† autoRefreshToken: true',
              'æ£€æŸ¥ src/services/supabase-client.service.ts ä¸­çš„é…ç½®'
            ]
          }
        ];
      } else if (results.specificError === 'USER_TOKEN_INVALID_AT_FUNCTION') {
        diagnosis = `
          <h3>ğŸ¯ é—®é¢˜å®šä½ï¼šToken é€šè¿‡äº† Supabase éªŒè¯å±‚ï¼Œä½†åœ¨ Edge Function å†…éƒ¨éªŒè¯å¤±è´¥</h3>
          <p>è¿™é€šå¸¸æ„å‘³ç€ Edge Function ä»£ç ä¸­çš„ <code>getUser()</code> è°ƒç”¨å¤±è´¥äº†ã€‚</p>
        `;
        
        fixes = [
          {
            title: 'æ£€æŸ¥ Edge Function çš„ Supabase Client é…ç½®',
            steps: [
              'æŸ¥çœ‹ supabase/functions/transcribe/index.ts',
              'ç¡®ä¿ SUPABASE_URL å’Œ SUPABASE_ANON_KEY ç¯å¢ƒå˜é‡æ­£ç¡®',
              'æ£€æŸ¥ Edge Function æ—¥å¿—ï¼š<code>supabase functions logs transcribe</code>'
            ]
          }
        ];
      } else if (results.specificError === 'TOKEN_EXPIRED') {
        diagnosis = `
          <h3>ğŸ¯ é—®é¢˜å®šä½ï¼šAccess Token å·²è¿‡æœŸ</h3>
          <p>Token å·²ç»è¿‡æœŸï¼Œéœ€è¦åˆ·æ–°æˆ–é‡æ–°ç™»å½•ã€‚</p>
        `;
        
        fixes = [
          {
            title: 'å¼ºåˆ¶åˆ·æ–° Token',
            steps: [
              'åœ¨æµè§ˆå™¨æ§åˆ¶å°æ‰§è¡Œï¼š',
              '<code>await supabase.auth.refreshSession();</code>',
              'ç„¶ååˆ·æ–°é¡µé¢é‡è¯•'
            ]
          },
          {
            title: 'é‡æ–°ç™»å½•',
            steps: [
              'é€€å‡ºç™»å½•ï¼Œç„¶åé‡æ–°ç™»å½•'
            ]
          }
        ];
      } else if (!results.hasSession) {
        diagnosis = `
          <h3>ğŸ¯ é—®é¢˜å®šä½ï¼šç”¨æˆ·æœªç™»å½•</h3>
          <p>å½“å‰æ²¡æœ‰æœ‰æ•ˆçš„ç”¨æˆ· Sessionã€‚</p>
        `;
        
        fixes = [
          {
            title: 'ç™»å½•è´¦æˆ·',
            steps: [
              'åœ¨åº”ç”¨ä¸­ç™»å½•ä½ çš„è´¦æˆ·',
              'ç¡®ä¿ç™»å½•æˆåŠŸåå†å°è¯•å½•éŸ³è½¬å†™'
            ]
          }
        ];
      } else {
        diagnosis = `
          <h3>ğŸ¤” éœ€è¦æ›´å¤šä¿¡æ¯</h3>
          <p>æ— æ³•ç¡®å®šå…·ä½“é—®é¢˜ï¼Œè¯·æŸ¥çœ‹ä¸Šé¢çš„è¯¦ç»†æµ‹è¯•ç»“æœã€‚</p>
          <pre>${JSON.stringify(results, null, 2)}</pre>
        `;
        
        fixes = [
          {
            title: 'æŸ¥çœ‹ Edge Function æ—¥å¿—',
            steps: [
              '<code>supabase functions logs transcribe --tail 100</code>',
              'æŸ¥æ‰¾å…·ä½“é”™è¯¯ä¿¡æ¯'
            ]
          },
          {
            title: 'ä½¿ç”¨ --no-verify-jwt é‡æ–°éƒ¨ç½²',
            steps: [
              '<code>supabase functions deploy transcribe --no-verify-jwt</code>',
              'è¿™æ˜¯æœ€å¯èƒ½è§£å†³é—®é¢˜çš„æ–¹æ¡ˆ'
            ]
          }
        ];
      }
      
      // è¾“å‡ºè¯Šæ–­ç»“æœ
      let html = `<div class="diagnosis-result">${diagnosis}`;
      
      if (fixes.length > 0) {
        html += '<h3>ğŸ”§ ä¿®å¤æ­¥éª¤</h3>';
        fixes.forEach((fix, i) => {
          html += `<div class="fix-step">
            <strong>${i + 1}. ${fix.title}</strong>
            <ul>${fix.steps.map(s => `<li>${s}</li>`).join('')}</ul>
          </div>`;
        });
      }
      
      html += `
        <h3>ğŸ“Š å®Œæ•´è¯Šæ–­æ•°æ®</h3>
        <pre>${JSON.stringify(diagnosisResults, null, 2)}</pre>
      </div>`;
      
      log(html, 'info');
    }
  </script>
</body>
</html>
