<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NanoFlow è¯­éŸ³è½¬å†™è¯Šæ–­å·¥å…·</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f4; color: #1c1917; min-height: 100vh; padding: 2rem; }
    .container { max-width: 640px; margin: 0 auto; }
    h1 { font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5rem; }
    .subtitle { color: #78716c; font-size: 0.875rem; margin-bottom: 2rem; }
    .card { background: white; border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .card h2 { font-size: 1rem; font-weight: 600; margin-bottom: 1rem; }
    label { display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem; color: #44403c; }
    input[type="text"], input[type="url"] { width: 100%; padding: 0.625rem 0.75rem; border: 1px solid #d6d3d1; border-radius: 8px; font-size: 0.875rem; margin-bottom: 0.75rem; }
    input:focus { outline: none; border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99,102,241,0.1); }
    button { padding: 0.625rem 1.25rem; border-radius: 8px; font-size: 0.875rem; font-weight: 600; cursor: pointer; border: none; transition: all 0.15s; }
    .btn-primary { background: #6366f1; color: white; }
    .btn-primary:hover { background: #4f46e5; }
    .btn-primary:disabled { background: #a5b4fc; cursor: not-allowed; }
    .btn-secondary { background: #e7e5e4; color: #1c1917; }
    .btn-secondary:hover { background: #d6d3d1; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-danger:hover { background: #dc2626; }
    .result { margin-top: 1rem; padding: 1rem; border-radius: 8px; font-size: 0.8125rem; font-family: 'SF Mono', 'Fira Code', monospace; white-space: pre-wrap; word-break: break-all; max-height: 300px; overflow-y: auto; }
    .result.success { background: #f0fdf4; border: 1px solid #bbf7d0; color: #166534; }
    .result.error { background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; }
    .result.info { background: #eff6ff; border: 1px solid #bfdbfe; color: #1e40af; }
    .steps { counter-reset: step; }
    .step { counter-increment: step; display: flex; align-items: flex-start; gap: 0.75rem; margin-bottom: 0.75rem; padding: 0.75rem; border-radius: 8px; background: #fafaf9; }
    .step::before { content: counter(step); background: #6366f1; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: 700; flex-shrink: 0; }
    .step.pass::before { content: 'âœ“'; background: #22c55e; }
    .step.fail::before { content: 'âœ—'; background: #ef4444; }
    .step.running::before { content: 'â€¦'; background: #f59e0b; }
    .step-content { flex: 1; }
    .step-title { font-weight: 600; font-size: 0.875rem; }
    .step-detail { font-size: 0.8125rem; color: #78716c; margin-top: 0.25rem; }
    .recording-indicator { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background: #fef2f2; border-radius: 8px; color: #ef4444; font-weight: 600; }
    .recording-dot { width: 10px; height: 10px; background: #ef4444; border-radius: 50%; animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    .gap { display: flex; gap: 0.5rem; flex-wrap: wrap; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ™ï¸ NanoFlow è¯­éŸ³è½¬å†™è¯Šæ–­å·¥å…·</h1>
    <p class="subtitle">éªŒè¯ Supabase Edge Function + Groq whisper-large-v3 çš„ç«¯åˆ°ç«¯è½¬å†™é“¾è·¯</p>

    <!-- é…ç½® -->
    <div class="card">
      <h2>1ï¸âƒ£ é…ç½®è¿æ¥ä¿¡æ¯</h2>
      <label for="supabaseUrl">Supabase Project URL</label>
      <input type="url" id="supabaseUrl" placeholder="https://your-project.supabase.co">
      <label for="anonKey">Supabase Anon Key</label>
      <input type="text" id="anonKey" placeholder="eyJhbGciOi...">
      <label for="functionName">Edge Function åç§°</label>
      <input type="text" id="functionName" value="transcribe" placeholder="transcribe">
    </div>

    <!-- è¯Šæ–­æ­¥éª¤ -->
    <div class="card">
      <h2>2ï¸âƒ£ è¿è¡Œè¯Šæ–­</h2>
      <div class="gap">
        <button class="btn-primary" onclick="runDiagnostics()" id="diagBtn">å¼€å§‹è¯Šæ–­</button>
        <button class="btn-secondary" onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
      </div>
      <div id="diagnosticSteps" class="steps" style="margin-top: 1rem;"></div>
    </div>

    <!-- å½•éŸ³æµ‹è¯• -->
    <div class="card">
      <h2>3ï¸âƒ£ å½•éŸ³è½¬å†™æµ‹è¯•</h2>
      <p style="font-size: 0.8125rem; color: #78716c; margin-bottom: 1rem;">
        æŒ‰ä½æŒ‰é’®å½•éŸ³ï¼Œæ¾å¼€åè‡ªåŠ¨å‘é€åˆ° Edge Function è¿›è¡Œè½¬å†™ã€‚
      </p>
      <div class="gap" style="align-items: center;">
        <button class="btn-danger" id="recordBtn"
          onmousedown="startRecording()" onmouseup="stopRecording()"
          ontouchstart="startRecording()" ontouchend="stopRecording()">
          ğŸ™ï¸ æŒ‰ä½è¯´è¯
        </button>
        <span id="recordingStatus"></span>
      </div>
      <div id="transcribeResult"></div>
    </div>
  </div>

  <script>
    // ========== è¯Šæ–­é€»è¾‘ ==========
    function getConfig() {
      return {
        url: document.getElementById('supabaseUrl').value.trim().replace(/\/$/, ''),
        key: document.getElementById('anonKey').value.trim(),
        fn: document.getElementById('functionName').value.trim() || 'transcribe',
      };
    }

    function addStep(containerId, title, detail, status) {
      const container = document.getElementById(containerId);
      const step = document.createElement('div');
      step.className = `step ${status}`;
      step.innerHTML = `<div class="step-content"><div class="step-title">${title}</div><div class="step-detail">${detail}</div></div>`;
      container.appendChild(step);
      return step;
    }

    function updateStep(stepEl, title, detail, status) {
      stepEl.className = `step ${status}`;
      stepEl.querySelector('.step-title').textContent = title;
      stepEl.querySelector('.step-detail').textContent = detail;
    }

    function clearResults() {
      document.getElementById('diagnosticSteps').innerHTML = '';
      document.getElementById('transcribeResult').innerHTML = '';
    }

    async function runDiagnostics() {
      const { url, key, fn } = getConfig();
      const container = 'diagnosticSteps';
      document.getElementById(container).innerHTML = '';
      document.getElementById('diagBtn').disabled = true;

      // Step 1: æ£€æŸ¥é…ç½®
      let step = addStep(container, 'æ£€æŸ¥é…ç½®', 'éªŒè¯ URL å’Œ Key æ ¼å¼...', 'running');
      if (!url || !key) {
        updateStep(step, 'é…ç½®ç¼ºå¤±', 'è¯·å¡«å†™ Supabase URL å’Œ Anon Key', 'fail');
        document.getElementById('diagBtn').disabled = false;
        return;
      }
      if (!url.includes('supabase.co') && !url.includes('supabase.in')) {
        updateStep(step, 'é…ç½®è­¦å‘Š', `URL ä¸æ˜¯æ ‡å‡† Supabase åŸŸå: ${url}ï¼ˆè‡ªå»ºå®ä¾‹å¯å¿½ç•¥ï¼‰`, 'pass');
      } else {
        updateStep(step, 'é…ç½®æ­£ç¡®', `URL: ${url.substring(0, 30)}...`, 'pass');
      }

      // Step 2: æµ‹è¯• Supabase è¿é€šæ€§
      step = addStep(container, 'æµ‹è¯• Supabase è¿é€šæ€§', 'å‘é€ HEAD è¯·æ±‚...', 'running');
      try {
        const resp = await fetch(`${url}/rest/v1/`, {
          method: 'HEAD',
          headers: { 'apikey': key, 'Authorization': `Bearer ${key}` }
        });
        if (resp.ok || resp.status === 200) {
          updateStep(step, 'Supabase è¿é€š', `çŠ¶æ€ç : ${resp.status}`, 'pass');
        } else {
          updateStep(step, 'Supabase å“åº”å¼‚å¸¸', `çŠ¶æ€ç : ${resp.status}`, 'fail');
        }
      } catch (e) {
        updateStep(step, 'Supabase è¿æ¥å¤±è´¥', e.message, 'fail');
        document.getElementById('diagBtn').disabled = false;
        return;
      }

      // Step 3: æµ‹è¯• Edge Function å¯è¾¾æ€§
      step = addStep(container, 'æµ‹è¯• Edge Function', `è¯·æ±‚ ${fn} å‡½æ•°...`, 'running');
      try {
        const resp = await fetch(`${url}/functions/v1/${fn}`, {
          method: 'POST',
          headers: {
            'apikey': key,
            'Authorization': `Bearer ${key}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ test: true })
        });
        const text = await resp.text();
        if (resp.status === 401) {
          updateStep(step, 'Edge Function è®¤è¯å¤±è´¥ (401)', 'å¯èƒ½åŸå› ï¼šAnon Key ä¸æ­£ç¡®ï¼Œæˆ–å‡½æ•°éœ€è¦ç™»å½•ç”¨æˆ·è®¤è¯', 'fail');
        } else if (resp.status === 404) {
          updateStep(step, 'Edge Function æœªæ‰¾åˆ° (404)', `å‡½æ•° "${fn}" å¯èƒ½æœªéƒ¨ç½²ã€‚è¿è¡Œ: supabase functions deploy ${fn}`, 'fail');
        } else if (resp.status === 400) {
          updateStep(step, 'Edge Function å¯è¾¾', `å‡½æ•°å­˜åœ¨å¹¶å“åº”ï¼ˆ400 = ç¼ºå°‘éŸ³é¢‘å‚æ•°ï¼Œè¿™æ˜¯é¢„æœŸçš„ï¼‰`, 'pass');
        } else {
          updateStep(step, `Edge Function å“åº”: ${resp.status}`, text.substring(0, 200), resp.ok ? 'pass' : 'fail');
        }
      } catch (e) {
        updateStep(step, 'Edge Function è¯·æ±‚å¤±è´¥', e.message, 'fail');
      }

      // Step 4: æ£€æŸ¥æµè§ˆå™¨å½•éŸ³æ”¯æŒ
      step = addStep(container, 'æ£€æŸ¥å½•éŸ³æ”¯æŒ', 'æ£€æµ‹ MediaRecorder API...', 'running');
      if (typeof MediaRecorder !== 'undefined') {
        const mimeTypes = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4', 'audio/ogg;codecs=opus'];
        const supported = mimeTypes.filter(m => MediaRecorder.isTypeSupported(m));
        updateStep(step, 'å½•éŸ³ API å¯ç”¨', `æ”¯æŒæ ¼å¼: ${supported.join(', ') || 'æ— ï¼ˆå¯èƒ½éœ€è¦ wav å›é€€ï¼‰'}`, 'pass');
      } else {
        updateStep(step, 'å½•éŸ³ API ä¸å¯ç”¨', 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ MediaRecorder', 'fail');
      }

      // Step 5: æ£€æŸ¥éº¦å…‹é£æƒé™
      step = addStep(container, 'æ£€æŸ¥éº¦å…‹é£æƒé™', 'è¯·æ±‚éº¦å…‹é£è®¿é—®...', 'running');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(t => t.stop());
        updateStep(step, 'éº¦å…‹é£æƒé™å·²æˆäºˆ', 'å¯ä»¥å½•éŸ³', 'pass');
      } catch (e) {
        updateStep(step, 'éº¦å…‹é£æƒé™è¢«æ‹’ç»', e.message, 'fail');
      }

      document.getElementById('diagBtn').disabled = false;
    }

    // ========== å½•éŸ³è½¬å†™æµ‹è¯• ==========
    let mediaRecorder = null;
    let audioChunks = [];

    async function startRecording() {
      const statusEl = document.getElementById('recordingStatus');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 16000 } });
        const mimeTypes = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4'];
        let mimeType = '';
        for (const m of mimeTypes) {
          if (MediaRecorder.isTypeSupported(m)) { mimeType = m; break; }
        }
        audioChunks = [];
        mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType, audioBitsPerSecond: 128000 } : { audioBitsPerSecond: 128000 });
        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) audioChunks.push(e.data); };
        mediaRecorder.start(100);
        statusEl.innerHTML = '<span class="recording-indicator"><span class="recording-dot"></span>å½•éŸ³ä¸­...</span>';
      } catch (e) {
        statusEl.textContent = 'âŒ æ— æ³•å½•éŸ³: ' + e.message;
      }
    }

    async function stopRecording() {
      const statusEl = document.getElementById('recordingStatus');
      const resultEl = document.getElementById('transcribeResult');
      if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
      
      mediaRecorder.stop();
      mediaRecorder.stream.getTracks().forEach(t => t.stop());
      statusEl.textContent = 'â³ æ­£åœ¨è½¬å†™...';

      // ç­‰å¾…æ•°æ®æ”¶é›†å®Œæ¯•
      await new Promise(r => { mediaRecorder.onstop = r; });
      
      const blob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
      if (blob.size < 1000) {
        statusEl.textContent = '';
        resultEl.innerHTML = '<div class="result error">å½•éŸ³å¤ªçŸ­ï¼Œè¯·æŒ‰ä½ä¹…ä¸€ç‚¹å†æ¾å¼€</div>';
        return;
      }

      const { url, key, fn } = getConfig();
      if (!url || !key) {
        statusEl.textContent = '';
        resultEl.innerHTML = '<div class="result error">è¯·å…ˆå¡«å†™ Supabase é…ç½®</div>';
        return;
      }

      const formData = new FormData();
      formData.append('file', blob, 'recording.webm');
      formData.append('model', 'whisper-large-v3');
      formData.append('language', 'zh');

      try {
        const startTime = performance.now();
        const resp = await fetch(`${url}/functions/v1/${fn}`, {
          method: 'POST',
          headers: {
            'apikey': key,
            'Authorization': `Bearer ${key}`,
          },
          body: formData
        });
        const elapsed = Math.round(performance.now() - startTime);
        const data = await resp.json();
        statusEl.textContent = '';

        if (resp.ok && data.text) {
          resultEl.innerHTML = `<div class="result success">âœ… è½¬å†™æˆåŠŸ (${elapsed}ms)\n\nè½¬å†™æ–‡æœ¬ï¼š${data.text}\n\néŸ³é¢‘å¤§å°ï¼š${(blob.size / 1024).toFixed(1)} KB\næ ¼å¼ï¼š${blob.type}</div>`;
        } else {
          resultEl.innerHTML = `<div class="result error">âŒ è½¬å†™å¤±è´¥ (HTTP ${resp.status}, ${elapsed}ms)\n\n${JSON.stringify(data, null, 2)}</div>`;
        }
      } catch (e) {
        statusEl.textContent = '';
        resultEl.innerHTML = `<div class="result error">âŒ è¯·æ±‚å¤±è´¥: ${e.message}</div>`;
      }
    }
  </script>
</body>
</html>
